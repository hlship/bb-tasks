(ns net.lewisship.bb.tasks
  "Define tasks for use with Babashka bb.edn."
  (:require
    [net.lewisship.bb.tasks.impl :as impl]))

(defn set-tool-name!
  "Changes the name of the tool, which appears in task help summaries.

  The default tool name is `bb`"
  [s]
  (alter-var-root #'impl/tool-name (constantly s)))

(defn set-prevent-exit!
  "Normally, after displaying a task summary, `System/exit` is called (with 0 if for --help,
   or 1 if a validation error).

   For testing purposes, this can be prevented; instead, an exception is thrown,
   with message \"Exit\" and ex-data {:status <status>}."
  [flag]
  (alter-var-root #'impl/prevent-exit (constantly flag)))

(defn print-summary
  "Prints the task's summary to `*out*`; partially generated by clojure.tools.cli, and then
  enhanced with more information about positional command line arguments.

  This is often used when a task performs additional validation of its arguments
  and needs to output the summary and errors on failure.

  Uses the task map that is available in `deftask` function.

  An :as clause in the `deftask` interface gives access to this task map.

  errors is a seq of strings to display as errors."
  [task-map errors]
  (impl/print-summary task-map errors))

(defmacro deftask
  "Defines a task for use with Babashka (:tasks defined in `bb.edn`).

   A task's _interface_ identifies how to parse command options and positional arguments,
   mapping them to local symbols.

   Tasks must always have a docstring; this is part of the `-h` / `--help` summary.

   Finally, the body inside a let that destructures the options and positional arguments into local symbols."
  [task-name docstring interface & body]
  (assert (simple-symbol? task-name)
          "deftask expects a symbol for command name")
  (assert (string? docstring)
          (throw "deftask requires a docstring"))
  (assert (vector? interface)
          "deftask expects a vector to define the interface")
  (let [symbol-meta (meta task-name)
        parsed-interface (impl/compile-interface docstring interface)
        {:keys [option-symbols arg-symbols task-map-symbol]
         :or {task-map-symbol (gensym "task-map-")}} parsed-interface
        let-terms (cond-> []
                    (seq option-symbols)
                    (into `[{:keys ~option-symbols} (:options ~task-map-symbol)])

                    (seq arg-symbols)
                    (into `[{:keys ~arg-symbols} (:arguments ~task-map-symbol)]))
        symbol-with-meta (assoc symbol-meta :doc docstring)]
    `(defn ~task-name
       ~symbol-with-meta
       ;; Zero args is for normal use, delegates to 2-arg supplying from the globals
       ([]
        ;; Not sure why this only works if fully qualified name
        (~task-name (babashka.tasks/current-task) *command-line-args*))
       ;; 2-arity does all the parsing and initial error reporting, then delegates
       ;; to the 1-arity for the real implementation.
       ([current-task# command-line-args#]
        (~task-name (impl/parse-cli current-task#
                                    command-line-args#
                                    ~(dissoc parsed-interface :option-symbols :arg-symbols))))
       ;; For testing, a task map may be passed to the 1-arity function.
       ([~task-map-symbol]
        (let [~@let-terms] ~@body)))))
